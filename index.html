<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jogo Splash Crazy</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background-color: #111;
      color: #0ff;
      font-family: Arial, sans-serif;
      display: flex;
    }
    #gameContainer {
      display: none;
      width: 1080px;
      height: 680px;
      gap: 20px;
    }
    #menu {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100vw;
      background-color: #000;
    }
    button {
      font-size: 24px;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
    }
    canvas {
      background: #000;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>Splash Crazy</h1>
    <button onclick="startGame()">Iniciar</button>
    <button onclick="openCharacterModal()">Personagem</button>
  </div>

  <div id="gameContainer">
    <canvas id="gameCanvas" width="1080" height="680"></canvas>
    <div id="characterModal" style="display: none; background: #222; padding: 10px; border: 2px solid #0ff;">
      <h2>Escolha seu personagem</h2>
      <div id="characterList"></div>
      <button onclick="closeCharacterModal()">Fechar</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const menu = document.getElementById("menu");
    const gameContainer = document.getElementById("gameContainer");
    const characterModal = document.getElementById("characterModal");
    const characterList = document.getElementById("characterList");

    let ball, paddle, bricks;
    let selectedBall = "padrÃ£o";
    let mouseDrag = false, lastMouseX;
    let touchStartX = 0, animationId = null;
    let aiming = false, aimStart = null;

    const characters = [
      { name: "padrÃ£o", unlock: () => true },
      { name: "ninja", unlock: () => confirm("Desbloquear ninja?") },
      { name: "fogo", unlock: () => confirm("Desbloquear fogo?") }
    ];

    function openCharacterModal() {
      renderCharacterList();
      characterModal.style.display = "block";
    }

    function closeCharacterModal() {
      characterModal.style.display = "none";
    }

    function renderCharacterList() {
      characterList.innerHTML = "";
      characters.forEach((char, idx) => {
        const btn = document.createElement("button");
        btn.innerText = char.name === selectedBall ? `âœ… ${char.name}` : char.name;
        btn.onclick = () => {
          if (characters[idx].unlock()) {
            selectedBall = characters[idx].name;
            renderCharacterList();
            setTimeout(() => characterModal.style.display = "none", 300);
          }
        };
        characterList.appendChild(btn);
      });
    }

    function startGame() {
      stopDraw(); // â›” Corrige aceleraÃ§Ã£o da bolinha
      menu.style.display = "none";
      gameContainer.style.display = "flex";
      resetGame();
      draw();
    }

    function showMenu() {
      stopDraw(); // â›” Cancela animaÃ§Ã£o ao sair
      gameContainer.style.display = "none";
      menu.style.display = "block";
    }

    function resetGame() {
      ball = {
        x: canvas.width / 2,
        y: canvas.height - 60,
        dx: 4,
        dy: -4,
        radius: 10,
        launched: false
      };
      paddle = {
        x: canvas.width / 2 - 75,
        y: canvas.height - 20,
        width: 150,
        height: 10
      };
      bricks = [];
      for (let r = 0; r < 5; r++) {
        for (let c = 0; c < 10; c++) {
          bricks.push({ x: c * 108 + 5, y: r * 30 + 30, status: 1 });
        }
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#0ff";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBricks() {
      bricks.forEach((b) => {
        if (b.status) {
          ctx.fillStyle = "#0f0";
          ctx.fillRect(b.x, b.y, 100, 20);
        }
      });
    }

    function drawAimArrow() {
      if (!ball.launched && aiming && aimStart) {
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(aimStart.x, aimStart.y);
        ctx.strokeStyle = "#f0f";
        ctx.stroke();
      }
    }

    function update() {
      if (ball.launched) {
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Paredes
        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
        if (ball.y - ball.radius < 0) ball.dy *= -1;

        // ColisÃ£o raquete
        if (ball.y + ball.radius > paddle.y && ball.y - ball.radius < paddle.y + paddle.height &&
            ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
          const hit = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          ball.dx = hit * 5;
          ball.dy = -Math.abs(ball.dy);
          ball.y = paddle.y - ball.radius;
        }

        // Tijolos
        bricks.forEach((b) => {
          if (b.status &&
              ball.x > b.x && ball.x < b.x + 100 &&
              ball.y > b.y && ball.y < b.y + 20) {
            b.status = 0;
            ball.dy *= -1;
          }
        });

        // Fim de jogo
        if (ball.y - ball.radius > canvas.height) showMenu();
      }

      // Limita raquete
      paddle.x = Math.max(0, Math.min(paddle.x, canvas.width - paddle.width));
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawAimArrow();
      update();
      animationId = requestAnimationFrame(draw); // ðŸ†• controla o loop
    }

    function stopDraw() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    // TOQUE
    canvas.addEventListener("touchstart", (e) => {
      if (!ball.launched) {
        aiming = true;
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        aimStart = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
      } else {
        touchStartX = e.touches[0].clientX;
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      if (ball.launched) {
        const deltaX = e.touches[0].clientX - touchStartX;
        paddle.x += deltaX;
        touchStartX = e.touches[0].clientX;
      }
    });

    canvas.addEventListener("touchend", () => {
      if (!ball.launched && aimStart) {
        ball.dx = (aimStart.x - ball.x) / 15;
        ball.dy = (aimStart.y - ball.y) / 15;
        ball.launched = true;
        aiming = false;
        aimStart = null;
      }
    });

    // MOUSE
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      if (!ball.launched) {
        aiming = true;
        aimStart = { x, y: e.clientY - rect.top };
      } else {
        mouseDrag = true;
        lastMouseX = x;
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (mouseDrag) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const deltaX = x - lastMouseX;
        paddle.x += deltaX;
        lastMouseX = x;
      }
    });

    canvas.addEventListener("mouseup", () => {
      if (!ball.launched && aimStart) {
        ball.dx = (aimStart.x - ball.x) / 15;
        ball.dy = (aimStart.y - ball.y) / 15;
        ball.launched = true;
        aiming = false;
        aimStart = null;
      }
      mouseDrag = false;
    });
  </script>
</body>
</html>