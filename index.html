<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Splash Crazy - Jogo da Bolinha Neon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #0ff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #container {
      text-align: center;
      max-width: 800px;
      width: 100%;
    }
    #gameCanvas {
      display: none;
      background: black;
      border: 4px solid #0ff;
      border-radius: 12px;
    }
    #menu, #characterMenu {
      margin-top: 20px;
    }
    button {
      background-color: #0ff;
      color: #111;
      border: none;
      padding: 10px 20px;
      font-size: 16px;
      margin: 5px;
      border-radius: 10px;
      cursor: pointer;
    }
    input, textarea {
      width: 90%;
      margin: 10px auto;
      padding: 8px;
      font-size: 14px;
      border-radius: 8px;
      border: none;
    }
    textarea {
      resize: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="menu">
      <h1>Splash Crazy - Jogo da Bolinha Neon</h1>
      <p>Selecione seu personagem:</p>
      <div id="characterMenu">
        <button onclick="selectCharacter('normal')">Bolinha Normal</button>
        <button onclick="selectCharacter('cristal')">Bolinha de Cristal</button>
        <button onclick="selectCharacter('ouro')">Bolinha de Ouro</button>
        <button onclick="selectCharacter('brilhando')">Bolinha Brilhando</button>
        <button onclick="selectCharacter('piscando')">Bolinha Piscando</button>
      </div>
      <button onclick="startGame()">Iniciar Jogo</button>

      <hr />
      <h2>Deixe seu comentário</h2>
      <form action="https://formsubmit.co/noahrosa8046@gmail.com" method="POST" target="_blank">
        <label for="name">Nome:</label>
        <input type="text" id="name" name="name" placeholder="Seu nome" required />

        <label for="message">Comentário / Sugestão:</label>
        <textarea id="message" name="message" placeholder="Escreva aqui..." required rows="4"></textarea>

        <input type="hidden" name="_captcha" value="false" />
        <button type="submit">Enviar</button>
      </form>
      <button id="backBtn" onclick="backToMenu()" style="display: none;">Voltar ao Menu</button>
    </div>

    <div id="gameArea">
      <canvas id="gameCanvas" width="800" height="640"></canvas>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const menu = document.getElementById("menu");
    const backBtn = document.getElementById("backBtn");

    let animationFrameId;
    let ballSpeedX = 4;
    let ballSpeedY = -4;
    let gameRunning = false;

    function cancelGameLoop() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    function resetBall() {
      ballX = canvas.width / 2;
      ballY = canvas.height - 30;
      ballSpeedX = 4;
      ballSpeedY = -4;
    }

    function backToMenu() {
      cancelGameLoop();
      gameRunning = false;
      menu.style.display = "block";
      canvas.style.display = "none";
      backBtn.style.display = "none";
    }

    function startGame() {
      resetGame();
      menu.style.display = "none";
      canvas.style.display = "block";
      backBtn.style.display = "inline-block";
      gameRunning = true;
      gameLoop(); // chamada única!
    }

    function resetGame() {
      // Reinicia tudo
      resetBall();
      // Reinicie outras variáveis como score, vidas etc, se necessário
    }

let paddleHeight = 10;
    let paddleWidth = 120;
    let paddleX = (canvas.width - paddleWidth) / 2;

    let rightPressed = false;
    let leftPressed = false;
    let touchX = null;

    let ballRadius = 10;
    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;

    let character = 'normal';

    let bricks = [];
    let brickRowCount = 3;
    let brickColumnCount = 5;
    let brickWidth = 75;
    let brickHeight = 20;
    let brickPadding = 10;
    let brickOffsetTop = 30;
    let brickOffsetLeft = 30;

    function selectCharacter(type) {
      character = type;
    }

    function createBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    createBricks();

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
      switch (character) {
        case 'cristal':
          ctx.fillStyle = "rgba(173, 216, 230, 0.8)";
          break;
        case 'ouro':
          ctx.fillStyle = "gold";
          break;
        case 'brilhando':
          ctx.fillStyle = "#0ff";
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#0ff";
          break;
        case 'piscando':
          ctx.fillStyle = (Date.now() % 500 < 250) ? "#0ff" : "#fff";
          break;
        default:
          ctx.fillStyle = "#0ff";
          break;
      }
      ctx.fill();
      ctx.closePath();
      ctx.shadowBlur = 0;
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0ff";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status == 1) {
            let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = "#0ff";
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          let b = bricks[c][r];
          if (b.status == 1) {
            if (
              ballX > b.x &&
              ballX < b.x + brickWidth &&
              ballY > b.y &&
              ballY < b.y + brickHeight
            ) {
              ballSpeedY = -ballSpeedY;
              b.status = 0;
            }
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      collisionDetection();

      if (
        ballX + ballSpeedX > canvas.width - ballRadius ||
        ballX + ballSpeedX < ballRadius
      ) {
        ballSpeedX = -ballSpeedX;
      }

      if (ballY + ballSpeedY < ballRadius) {
        ballSpeedY = -ballSpeedY;
      } else if (ballY + ballSpeedY > canvas.height - ballRadius) {
        if (ballX > paddleX && ballX < paddleX + paddleWidth) {
          ballSpeedY = -ballSpeedY;
        } else {
          cancelGameLoop();
          alert("Fim de jogo!");
          document.location.reload();
        }
      }

      ballX += ballSpeedX;
      ballY += ballSpeedY;

      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      if (gameRunning) {
        draw();
      }
    }

    // Eventos teclado
    document.addEventListener("keydown", (e) => {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
    });

    document.addEventListener("keyup", (e) => {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    });

    // Eventos touch
    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1) {
        const rect = canvas.getBoundingClientRect();
        touchX = e.touches[0].clientX - rect.left;
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      if (e.touches.length == 1) {
        const rect = canvas.getBoundingClientRect();
        const moveX = e.touches[0].clientX - rect.left;
        const dx = moveX - touchX;
        paddleX += dx;
        touchX = moveX;
        if (paddleX < 0) paddleX = 0;
        if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
      }
    });

    // Mouse (arrastar)
    let isDragging = false;
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
    });
    canvas.addEventListener("mouseup", () => {
      isDragging = false;
    });
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        paddleX = x - paddleWidth / 2;
        if (paddleX < 0) paddleX = 0;
        if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
      }
    });
  </script>
</body>
</html>