<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Splash Crazy - Jogo da Bolinha Neon</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #0ff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #menu, #gameContainer {
      background: #111;
      border: 2px solid cyan;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 0 20px cyan;
      text-align: center;
    }
    #menu {
      width: 320px;
    }
    #gameContainer {
      display: none;
      width: 1080px;
      height: 680px;
      display: flex;
      gap: 20px;
    }
    button {
      display: block;
      width: 180px;
      padding: 10px;
      margin: 10px auto;
      font-size: 16px;
      border: 2px solid cyan;
      border-radius: 10px;
      background-color: black;
      color: cyan;
      cursor: pointer;
      transition: 0.3s;
    }
    button:hover {
      background-color: cyan;
      color: black;
      font-weight: bold;
    }
    #sidebar {
      margin: 0;
      padding: 20px;
      color: #0ff;
      width: 240px;
      font-size: 14px;
      background-color: #111;
      border-radius: 12px;
      box-shadow: 0 0 15px cyan;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    #sidebar h1 {
      color: #0ff;
      font-size: 20px;
      margin-bottom: 10px;
    }
    #sidebar h2 {
      margin-top: 20px;
      font-size: 16px;
    }
    #sidebar label {
      font-weight: bold;
      display: block;
      margin-bottom: 4px;
    }
    #sidebar input[type="text"], #sidebar textarea {
      width: 100%;
      margin-bottom: 12px;
      padding: 6px;
      border: 1px solid #0ff;
      border-radius: 4px;
      background-color: #111;
      color: #0ff;
      resize: vertical;
      font-family: Arial, sans-serif;
      font-size: 14px;
    }
    #sidebar input[type="text"]::placeholder,
    #sidebar textarea::placeholder {
      color: #0aa;
    }
    #sidebar button {
      background-color: #0ff;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      color: #111;
      font-weight: bold;
      border-radius: 4px;
      font-size: 14px;
      transition: background-color 0.3s ease;
    }
    #sidebar button:hover {
      background-color: #0cc;
    }
    #sidebar hr {
      border-color: #0ff;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    #gameArea {
      border: 2px solid cyan;
      background-color: #222;
      border-radius: 12px;
      position: relative;
      box-shadow: 0 0 20px cyan;
      flex-grow: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      background-color: #000;
      border-radius: 10px;
      touch-action: none; /* importante para touch */
    }
    #backBtn {
      margin-top: 15px;
      width: auto;
      padding: 6px 12px;
      font-size: 14px;
    }
    /* Modal de seleção de personagem */
    #characterModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #000;
      border: 2px solid cyan;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 0 20px cyan;
      z-index: 1000;
      width: 320px;
      text-align: left;
      color: #0ff;
    }
    #characterModal h2 {
      text-align: center;
      margin-bottom: 15px;
    }
    #closeModalBtn {
      background-color: red;
      color: white;
      width: auto;
      padding: 4px 12px;
      font-size: 14px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      display: block;
      margin: 10px auto 0;
    }
    .ball-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      margin: 4px 0;
      border: 1px solid #0ff;
      border-radius: 8px;
    }
    .locked {
      opacity: 0.4;
    }
    .ball-option button {
      background-color: black;
      border: 1px solid cyan;
      border-radius: 6px;
      color: cyan;
      cursor: pointer;
      padding: 4px 12px;
      transition: 0.3s;
    }
    .ball-option button:hover:not(:disabled) {
      background-color: cyan;
      color: black;
      font-weight: bold;
    }
    .ball-option button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <!-- MENU INICIAL -->
  <div id="menu">
    <h1>Menu Principal</h1>
    <button id="startBtn">Start</button>
    <button id="charBtn">Characters</button>
    <button onclick="alert('Saindo do jogo...')">Exit</button>
  </div>

  <!-- CONTAINER DO JOGO + SIDEBAR -->
  <div id="gameContainer">
    <div id="sidebar">
      <h1>Jogo da Bolinha Neon</h1>
      <p><strong>Jogador:</strong> <span id="playerName">---</span></p>
      <p><strong>Pontuação:</strong> <span id="score">0</span></p>
      <p><strong>Recorde:</strong> <span id="highScore">0</span></p>
      <p><strong>Vidas:</strong> <span id="lives">3</span></p>
      <p><strong>Fase:</strong> <span id="level">1</span></p>

      <hr />

      <h2>Deixe seu comentário</h2>
      <form action="https://formsubmit.co/noahrosa8046@gmail.com" method="POST" target="_blank">
        <label for="name">Nome:</label>
        <input type="text" id="name" name="name" placeholder="Seu nome" required />

        <label for="message">Comentário / Sugestão:</label>
        <textarea id="message" name="message" placeholder="Escreva aqui..." required rows="4"></textarea>

        <input type="hidden" name="_captcha" value="false" />

        <button type="submit">Enviar</button>
      </form>
      <button id="backBtn">Voltar ao Menu</button>
    </div>

    <div id="gameArea">
      <canvas id="gameCanvas" width="800" height="640"></canvas>
    </div>
  </div>

  <!-- MODAL DE SELEÇÃO DE PERSONAGEM -->
  <div id="characterModal">
    <h2>Escolha sua Bolinha</h2>
    <div id="characterList"></div>
    <button id="closeModalBtn">Fechar</button>
  </div>

  <script>
    // Elementos principais
    const menu = document.getElementById("menu");
    const gameContainer = document.getElementById("gameContainer");
    const startBtn = document.getElementById("startBtn");
    const backBtn = document.getElementById("backBtn");
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // HUD
    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const livesEl = document.getElementById("lives");
    const levelEl = document.getElementById("level");
    const playerNameEl = document.getElementById("playerName");

    // Modal de personagens
    const charBtn = document.getElementById("charBtn");
    const characterModal = document.getElementById("characterModal");
    const characterList = document.getElementById("characterList");
    const closeModalBtn = document.getElementById("closeModalBtn");

    // Variáveis do jogador
    let playerName = prompt("Digite seu nome:");
    playerNameEl.textContent = playerName || "Desconhecido";

    let score = 0;
    let highScore = 0;
    let lives = 3;
    let level = 1;

    // Posição e tamanho da raquete (paddle)
    let paddle = {
      x: canvas.width / 2 - 40,
      y: canvas.height - 20,
      width: 80,
      height: 10,
      dx: 0
    };

    // Bolinha
    let ball = {
      x: canvas.width / 2,
      y: canvas.height - 30,
      radius: 8,
      dx: 0,
      dy: 0
    };

    // Tabela de blocos (bricks)
    const brickRowCount = 5;
    const brickColumnCount = 8;
    const brickWidth = 50;
    const brickHeight = 15;
    const brickPadding = 8;
    const brickOffsetTop = 40;
    const brickOffsetLeft = 20;

    let bricks = [];
    let hitCount = [];

    // Controle do lançamento da bola
    let isAiming = false;
    let launched = false;
    let aimStart = null;
    let aimEnd = null;

    // Variáveis para controle do drag da raquete
    let isDraggingPaddle = false;
    let lastDragX = 0;

    // Personagens (bolinhas) e desbloqueios
    const characters = [
      { name: "Bola Clássica", unlock: () => true },
      { name: "Bola de Cristal", unlock: () => level >= 3 },
      { name: "Bola de Ouro", unlock: () => score >= 1000 },
      { name: "Bola Brilhando", unlock: () => level >= 5 },
      { name: "Bola Piscando", unlock: () => score >= 2000 }
    ];
    let selectedBall = "Bola Clássica";

    // Funções para criar e desenhar bricks
    function createBricks() {
      bricks = [];
      hitCount = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        hitCount[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
          hitCount[c][r] = 0;
        }
      }
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status > 0) {
            let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;

            ctx.fillStyle = hitCount[c][r] === 0 ? "#0f0" : hitCount[c][r] === 1 ? "#ff0" : "#f00";
            ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
          }
        }
      }
    }

    // Desenha a bola usando a bolinha selecionada
    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      switch (selectedBall) {
        case "Bola Clássica":
          ctx.fillStyle = "cyan";
          break;
        case "Bola de Cristal":
          ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
          break;
        case "Bola de Ouro":
          ctx.fillStyle = "gold";
          break;
        case "Bola Brilhando":
          ctx.fillStyle = "lime";
          break;
        case "Bola Piscando":
          ctx.fillStyle = Math.random() > 0.5 ? "magenta" : "cyan";
          break;
        default:
          ctx.fillStyle = "cyan";
      }
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawAimArrow() {
      if (isAiming && aimStart && aimEnd) {
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(aimStart.x, aimStart.y);
        ctx.lineTo(aimEnd.x, aimEnd.y);
        ctx.stroke();

        const angle = Math.atan2(aimEnd.y - aimStart.y, aimEnd.x - aimStart.x);
        const arrowLength = 15;
        ctx.beginPath();
        ctx.moveTo(aimEnd.x, aimEnd.y);
        ctx.lineTo(
          aimEnd.x - arrowLength * Math.cos(angle - Math.PI / 6),
          aimEnd.y - arrowLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          aimEnd.x - arrowLength * Math.cos(angle + Math.PI / 6),
          aimEnd.y - arrowLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.lineTo(aimEnd.x, aimEnd.y);
        ctx.fillStyle = "#fff";
        ctx.fill();
      }
    }

// Atualiza posição da bola e checa colisões
    function updateBall() {
      if (!launched) {
        // Se não lançado, bola acompanha a raquete
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddle.y - ball.radius;
        return;
      }

      ball.x += ball.dx;
      ball.y += ball.dy;

      // Colisão com paredes laterais
      if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
      }
      // Colisão com topo
      if (ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
      }
      // Colisão com paddle
      if (
        ball.y + ball.radius > paddle.y &&
        ball.x > paddle.x &&
        ball.x < paddle.x + paddle.width
      ) {
        ball.dy = -Math.abs(ball.dy); // força a bola a subir
        // Ajusta dx baseado na posição da bola na raquete para controle do ângulo
        let collidePoint = ball.x - (paddle.x + paddle.width / 2);
        collidePoint = collidePoint / (paddle.width / 2);
        const maxAngle = Math.PI / 3; // 60 graus
        const angle = collidePoint * maxAngle;
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
        ball.dx = speed * Math.sin(angle);
        ball.dy = -speed * Math.cos(angle);
      }
      // Bola caiu abaixo do paddle (perdeu vida)
      if (ball.y - ball.radius > canvas.height) {
        lives--;
        updateHUD();
        if (lives <= 0) {
          alert("Game Over!");
          resetGame();
          return;
        }
        resetBall();
      }

      // Checar colisão com bricks
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          let b = bricks[c][r];
          if (b.status > 0) {
            if (
              ball.x > b.x &&
              ball.x < b.x + brickWidth &&
              ball.y > b.y &&
              ball.y < b.y + brickHeight
            ) {
              ball.dy = -ball.dy;
              hitCount[c][r]++;
              if (hitCount[c][r] >= 2) {
                b.status = 0;
                score += 100;
                updateHUD();
                // Checar se venceu a fase
                if (isLevelCleared()) {
                  level++;
                  alert("Parabéns! Passou para a fase " + level);
                  nextLevel();
                }
              }
            }
          }
        }
      }
    }

    function updateHUD() {
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      levelEl.textContent = level;
      if (score > highScore) {
        highScore = score;
        highScoreEl.textContent = highScore;
      }
    }

    // Reinicia a bola para posição inicial e velocidade padrão, sem acumular velocidade
    function resetBall() {
      launched = false;
      ball.x = paddle.x + paddle.width / 2;
      ball.y = paddle.y - ball.radius;
      // Velocidade inicial zerada até lançamento
      ball.dx = 0;
      ball.dy = 0;
      aimStart = null;
      aimEnd = null;
      isAiming = false;
    }

    // Reinicia o jogo inteiro
    function resetGame() {
      lives = 3;
      score = 0;
      level = 1;
      createBricks();
      resetBall();
      updateHUD();
    }

    // Próxima fase: aumenta dificuldade
    function nextLevel() {
      createBricks();
      resetBall();
      updateHUD();
    }

    // Checa se todos os bricks foram destruídos
    function isLevelCleared() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status > 0) {
            return false;
          }
        }
      }
      return true;
    }

    // Desenha tudo a cada frame
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawPaddle();
      drawBall();
      drawAimArrow();
    }

    // Loop principal do jogo
    function gameLoop() {
      updateBall();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Eventos mouse para paddle e lançamento da bola com seta
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Se clicar na paddle, iniciar drag
      if (
        mouseY > paddle.y &&
        mouseY < paddle.y + paddle.height &&
        mouseX > paddle.x &&
        mouseX < paddle.x + paddle.width
      ) {
        isDraggingPaddle = true;
        lastDragX = mouseX;
      } else if (!launched) {
        // Se clicar fora da paddle e não lançado, inicia mira
        isAiming = true;
        aimStart = { x: ball.x, y: ball.y };
        aimEnd = { x: mouseX, y: mouseY };
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      if (isDraggingPaddle) {
        let deltaX = mouseX - lastDragX;
        paddle.x += deltaX;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
        lastDragX = mouseX;
        if (!launched) {
          ball.x = paddle.x + paddle.width / 2;
          ball.y = paddle.y - ball.radius;
        }
      } else if (isAiming) {
        aimEnd = { x: mouseX, y: mouseY };
      }
    });

    canvas.addEventListener("mouseup", (e) => {
      if (isDraggingPaddle) {
        isDraggingPaddle = false;
      }
      if (isAiming && !launched) {
        // Calcula direção e velocidade da bola no lançamento
        let dx = aimStart.x - aimEnd.x;
        let dy = aimStart.y - aimEnd.y;
        let magnitude = Math.sqrt(dx * dx + dy * dy);
        if (magnitude > 0) {
          let speed = 5; // velocidade constante ao lançar
          ball.dx = (dx / magnitude) * speed;
          ball.dy = (dy / magnitude) * speed;
          launched = true;
        }
        isAiming = false;
        aimStart = null;
        aimEnd = null;
      }
    });

    // Controle por toque (touch) para dispositivos móveis
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      // Se tocar na paddle, iniciar drag
      if (
        touchY > paddle.y &&
        touchY < paddle.y + paddle.height &&
        touchX > paddle.x &&
        touchX < paddle.x + paddle.width
      ) {
        isDraggingPaddle = true;
        lastDragX = touchX;
      } else if (!launched) {
        // Se tocar fora da paddle e não lançado, iniciar mira
        isAiming = true;
        aimStart = { x: ball.x, y: ball.y };
        aimEnd = { x: touchX, y: touchY };
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const touchX = touch.clientX - rect.left;
      const touchY = touch.clientY - rect.top;

      if (isDraggingPaddle) {
        let deltaX = touchX - lastDragX;
        paddle.x += deltaX;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
        lastDragX = touchX;
        if (!launched) {
          ball.x = paddle.x + paddle.width / 2;
          ball.y = paddle.y - ball.radius;
        }
      } else if (isAiming) {
        aimEnd = { x: touchX, y: touchY };
      }
    });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (isDraggingPaddle) {
        isDraggingPaddle = false;
      }
      if (isAiming && !launched) {
        let dx = aimStart.x - aimEnd.x;
        let dy = aimStart.y - aimEnd.y;
        let magnitude = Math.sqrt(dx * dx + dy * dy);
        if (magnitude > 0) {
          let speed = 5;
          ball.dx = (dx / magnitude) * speed;
          ball.dy = (dy / magnitude) * speed;
          launched = true;
        }
        isAiming = false;
        aimStart = null;
        aimEnd = null;
      }
    });

    // Botões menu e voltar
    startBtn.addEventListener("click", () => {
      menu.style.display = "none";
      gameContainer.style.display = "flex";
      resetGame();
      gameLoop();
    });

    backBtn.addEventListener("click", () => {
      gameContainer.style.display = "none";
      menu.style.display = "block";
    });

    // Modal de personagem
    charBtn.addEventListener("click", () => {
      characterModal.style.display = "block";
      renderCharacterList();
    });

    closeModalBtn.addEventListener("click", () => {
      characterModal.style.display = "none";
    });

    // Renderiza lista de personagens com desbloqueio
    function renderCharacterList() {
      characterList.innerHTML = "";
      characters.forEach((char) => {
        const unlocked = char.unlock();
        const div = document.createElement("div");
        div.className = "ball-option" + (unlocked ? "" : " locked");
        div.innerHTML = `
          <span>${char.name}</span>
          <button ${!unlocked ? "disabled" : ""} data-name="${char.name}">
            ${char.name === selectedBall ? "Selecionado" : "Selecionar"}
          </button>
        `;
        characterList.appendChild(div);
      });

      // Adiciona evento aos botões
      characterList.querySelectorAll("button").forEach((btn) => {
        btn.addEventListener("click", () => {
          selectedBall = btn.getAttribute("data-name");
          characterModal.style.display = "none";
        });
      });
    }

    // Inicializa o jogo
    createBricks();
    updateHUD();
    resetBall();

  </script>
</body>
</html>