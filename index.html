<!-- PARTE 1 -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Splash Crazy - Jogo da Bolinha Neon</title>
  <style>
    /* ... seu CSS original completo aqui ... */
  </style>
</head>
<body>
  <!-- MENU -->
  <div id="menu">
    <!-- ... conteúdo do menu ... -->
  </div>

  <!-- GAME CONTAINER -->
  <div id="gameContainer">
    <!-- SIDEBAR E GAME AREA -->
  </div>

  <!-- MODAL DE PERSONAGEM -->
  <div id="characterModal">
    <!-- ... conteúdo do modal ... -->
  </div>

  <!-- PARTE 2 - SCRIPT -->
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let ballX = canvas.width / 2;
    let ballY = canvas.height - 60;
    let ballRadius = 10;
    let ballSpeedX = 5;
    let ballSpeedY = -5;

    const paddleHeight = 10;
    const paddleWidth = 100;
    let paddleX = (canvas.width - paddleWidth) / 2;

    let rightPressed = false;
    let leftPressed = false;
    let isDragging = false;
    let draggingTouchId = null;

    let bricks = [];
    let brickRowCount = 3;
    let brickColumnCount = 5;
    const brickWidth = 75;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 30;

    let score = 0;
    let lives = 3;
    let level = 1;
    let highScore = 0;

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI*2);
      ctx.fillStyle = '#0ff';
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight - 10, paddleWidth, paddleHeight);
      ctx.fillStyle = '#0ff';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      bricks.forEach(b => {
        if (!b.destroyed) {
          ctx.beginPath();
          ctx.rect(b.x, b.y, brickWidth, brickHeight);
          ctx.fillStyle = '#0ff';
          ctx.fill();
          ctx.closePath();
        }
      });
    }

    function loadBricks() {
      bricks = [];
      for(let c=0; c<brickColumnCount; c++) {
        for(let r=0; r<brickRowCount; r++) {
          const brickX = (c*(brickWidth+brickPadding)) + brickOffsetLeft;
          const brickY = (r*(brickHeight+brickPadding)) + brickOffsetTop;
          bricks.push({ x: brickX, y: brickY, destroyed: false });
        }
      }
    }

    function collisionDetection() {
      bricks.forEach(b => {
        if (!b.destroyed) {
          if(ballX > b.x && ballX < b.x + brickWidth && ballY > b.y && ballY < b.y + brickHeight) {
            ballSpeedY = -ballSpeedY;
            b.destroyed = true;
            score++;
            if(score > highScore) highScore = score;
          }
        }
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBall();
      drawPaddle();
      drawBricks();
    }

    function update() {
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      if(ballX + ballRadius > canvas.width || ballX - ballRadius < 0) ballSpeedX = -ballSpeedX;
      if(ballY - ballRadius < 0) ballSpeedY = -ballSpeedY;
      else if(ballY + ballRadius > canvas.height) {
        if(ballX > paddleX && ballX < paddleX + paddleWidth) {
          ballSpeedY = -ballSpeedY;
        } else {
          lives--;
          if(!lives) {
            alert('Game Over');
            restartGame();
          } else {
            resetBall();
            resetPaddle();
          }
        }
      }

      if(rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 7;
      if(leftPressed && paddleX > 0) paddleX -= 7;

      collisionDetection();
      updateUI();
    }

    document.addEventListener("keydown", e => {
      if(e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if(e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
    });

    document.addEventListener("keyup", e => {
      if(e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if(e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    });

    canvas.addEventListener("touchstart", function(e) {
      const touch = e.changedTouches[0];
      if (touch.clientX >= paddleX && touch.clientX <= paddleX + paddleWidth) {
        isDragging = true;
        draggingTouchId = touch.identifier;
      }
    });

    canvas.addEventListener("touchmove", function(e) {
      for (let i = 0; i < e.changedTouches.length; i++) {
        const touch = e.changedTouches[i];
        if (isDragging && touch.identifier === draggingTouchId) {
          const rect = canvas.getBoundingClientRect();
          let newX = touch.clientX - rect.left - paddleWidth / 2;
          newX = Math.max(0, Math.min(canvas.width - paddleWidth, newX));
          paddleX = newX;
        }
      }
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener("touchend", function(e) {
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === draggingTouchId) {
          isDragging = false;
          draggingTouchId = null;
        }
      }
    });

    function resetBall() {
      ballX = canvas.width / 2;
      ballY = canvas.height - 60;
    }

    function resetPaddle() {
      paddleX = (canvas.width - paddleWidth) / 2;
    }

    function updateUI() {
      scoreEl.textContent = score;
      levelEl.textContent = level;
      livesEl.textContent = lives;
    }

    // ✅ CORREÇÃO DO BUG DE VELOCIDADE:
    function restartGame() {
      score = 0;
      level = 1;
      lives = 3;
      ballSpeedX = 5;   // <- RESET
      ballSpeedY = -5;  // <- RESET
      isDragging = false;
      draggingTouchId = null;
      loadBricks();
      resetBall();
      resetPaddle();
      updateUI();
    }

    function gameLoop() {
      draw();
      update();
      requestAnimationFrame(gameLoop);
    }

    loadBricks();
    gameLoop();
  </script>
</body>
</html>